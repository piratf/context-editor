# 多环境支持测试方案

## 1. 测试策略

### 1.1 分阶段测试

```
┌─────────────────────────────────────────────────────────────┐
│                    第一阶段：单元测试                        │
│  目标：90%+ 覆盖率，全部通过                                 │
│  范围：各模块独立功能，使用 Mock 隔离                        │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│                    第二阶段：集成测试                        │
│  目标：模块协作正确，跨环境功能验证                          │
│  范围：真实环境下的端到端场景                                │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 测试优先级

| 优先级 | 测试类型 | 覆盖率目标 | 通过要求 |
|:---:|:---|:---:|:---|
| **P0** | 单元测试 | 90%+ | 100% |
| P1 | 集成测试 | - | 100% |

---

## 2. 单元测试

### 2.1 测试工具

- **框架**: Mocha
- **断言**: Assert (Node.js 内置)
- **Mock**: Sinon.js
- **文件系统**: memfs (内存文件系统)
- **覆盖率**: c8

### 2.2 运行命令

```bash
# 运行所有单元测试
npm run test

# 运行单个测试文件
npm run test -- environment.test.ts

# 覆盖率报告
npm run test:coverage

# 监听模式（开发时使用）
npm run test:watch
```

---

### 2.3 环境层 (Environment)

**测试文件**: `src/test/unit/environment.test.ts`

#### 测试用例

```typescript
describe('Environment', () => {
  describe('环境类型检测', () => {
    it('should detect Windows environment', () => {
      const platformStub = sinon.stub(process, 'platform').value('win32');
      const env = new Environment();
      assert.strictEqual(env.type, EnvironmentType.Windows);
      assert.ok(env.isWindows());
      platformStub.restore();
    });

    it('should detect WSL environment (from /proc/version)', () => {
      const platformStub = sinon.stub(process, 'platform').value('linux');
      const fsStub = sinon.stub(fs, 'readFileSync').returns('Microsoft');
      const env = new Environment();
      assert.strictEqual(env.type, EnvironmentType.WSL);
      assert.ok(env.isWSL());
      platformStub.restore();
      fsStub.restore();
    });

    it('should detect macOS environment', () => {
      const platformStub = sinon.stub(process, 'platform').value('darwin');
      const env = new Environment();
      assert.strictEqual(env.type, EnvironmentType.MacOS);
      assert.ok(env.isMacOS());
      platformStub.restore();
    });

    it('should detect Linux environment', () => {
      const platformStub = sinon.stub(process, 'platform').value('linux');
      const fsStub = sinon.stub(fs, 'readFileSync').returns('Linux');
      const env = new Environment();
      assert.strictEqual(env.type, EnvironmentType.Linux);
      assert.ok(env.isLinux());
      platformStub.restore();
      fsStub.restore();
    });
  });

  describe('Home 目录', () => {
    it('should return correct home directory on Windows', () => {
      const platformStub = sinon.stub(process, 'platform').value('win32');
      const envStub = sinon.stub(process, 'env').value({ USERPROFILE: 'C:\\Users\\test' });
      const env = new Environment();
      assert.strictEqual(env.homeDir, 'C:\\Users\\test');
      platformStub.restore();
      envStub.restore();
    });

    it('should return correct home directory on Unix', () => {
      const platformStub = sinon.stub(process, 'platform').value('linux');
      const envStub = sinon.stub(process, 'env').value({ HOME: '/home/test' });
      const env = new Environment();
      assert.strictEqual(env.homeDir, '/home/test');
      platformStub.restore();
      envStub.restore();
    });
  });

  describe('平台无关接口', () => {
    describe('getConfigPath()', () => {
      it('should return Windows config path', () => {
        const platformStub = sinon.stub(process, 'platform').value('win32');
        const envStub = sinon.stub(process, 'env').value({ USERPROFILE: 'C:\\Users\\test' });
        const env = new Environment();
        assert.strictEqual(env.getConfigPath(), 'C:\\Users\\test\\.claude.json');
        platformStub.restore();
        envStub.restore();
      });

      it('should return macOS config path', () => {
        const platformStub = sinon.stub(process, 'platform').value('darwin');
        const envStub = sinon.stub(process, 'env').value({ HOME: '/Users/test' });
        const env = new Environment();
        assert.strictEqual(env.getConfigPath(), '/Users/test/.claude.json');
        platformStub.restore();
        envStub.restore();
      });

      it('should return Linux config path', () => {
        const platformStub = sinon.stub(process, 'platform').value('linux');
        const envStub = sinon.stub(process, 'env').value({ HOME: '/home/test' });
        const env = new Environment();
        assert.strictEqual(env.getConfigPath(), '/home/test/.claude.json');
        platformStub.restore();
        envStub.restore();
      });
    });

    describe('joinPath()', () => {
      it('should use backslash on Windows', () => {
        const platformStub = sinon.stub(process, 'platform').value('win32');
        const env = new Environment();
        const result = env.joinPath('home', 'user', 'project');
        assert.strictEqual(result, 'home\\user\\project');
        platformStub.restore();
      });

      it('should use forward slash on Unix', () => {
        const platformStub = sinon.stub(process, 'platform').value('linux');
        const env = new Environment();
        const result = env.joinPath('home', 'user', 'project');
        assert.strictEqual(result, 'home/user/project');
        platformStub.restore();
      });
    });
  });

  describe('单例模式', () => {
    it('should return same instance', () => {
      const env1 = Environment.getInstance();
      const env2 = Environment.getInstance();
      assert.strictEqual(env1, env2);
    });
  });

  describe('只读属性', () => {
    it('should not allow modifying type', () => {
      const env = new Environment();
      assert.throws(() => {
        (env as any).type = EnvironmentType.MacOS;
      });
    });

    it('should not allow modifying homeDir', () => {
      const env = new Environment();
      assert.throws(() => {
        (env as any).homeDir = '/other';
      });
    });
  });
});
```

#### 覆盖率目标: 100%

---

### 2.4 路径转换层 (PathConverter)

**测试文件**: `src/test/unit/pathConverter.test.ts`

#### WslToWindowsPathConverter

```typescript
describe('WslToWindowsPathConverter', () => {
  describe('基本路径转换', () => {
    it('should convert WSL home path to Windows UNC path', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      const result = converter.convert('/home/user/project');
      assert.strictEqual(result, '\\\\wsl.localhost\\Ubuntu\\home\\user\\project');
    });

    it('should convert WSL root path', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      const result = converter.convert('/var/log');
      assert.strictEqual(result, '\\\\wsl.localhost\\Ubuntu\\var\\log');
    });

    it('should preserve filename extension', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      const result = converter.convert('/home/user/file.txt');
      assert.strictEqual(result, '\\\\wsl.localhost\\Ubuntu\\home\\user\\file.txt');
    });

    it('should handle path with multiple segments', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      const result = converter.convert('/home/user/projects/myapp/src');
      assert.strictEqual(result, '\\\\wsl.localhost\\Ubuntu\\home\\user\\projects\\myapp\\src');
    });
  });

  describe('多实例支持', () => {
    it('should handle Ubuntu-22.04 instance', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu-22.04');
      const result = converter.convert('/home/user/project');
      assert.strictEqual(result, '\\\\wsl.localhost\\Ubuntu-22.04\\home\\user\\project');
    });

    it('should handle Debian instance', () => {
      const converter = new WslToWindowsPathConverter('Debian');
      const result = converter.convert('/home/user/project');
      assert.strictEqual(result, '\\\\wsl.localhost\\Debian\\home\\user\\project');
    });
  });

  describe('边界情况', () => {
    it('should throw error on empty path', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      assert.throws(() => converter.convert(''));
    });

    it('should handle path with spaces', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      const result = converter.convert('/home/user/my project');
      assert.strictEqual(result, '\\\\wsl.localhost\\Ubuntu\\home\\user\\my project');
    });

    it('should handle path with unicode characters', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      const result = converter.convert('/home/user/项目');
      assert.ok(result.includes('项目'));
    });

    it('should handle relative path', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      const result = converter.convert('../project');
      assert.strictEqual(result, '\\\\wsl.localhost\\Ubuntu\\..\\project');
    });

    it('should handle path with trailing slash', () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      const result = converter.convert('/home/user/');
      assert.strictEqual(result, '\\\\wsl.localhost\\Ubuntu\\home\\user\\');
    });
  });

  describe('路径格式降级', () => {
    it('should use old format when new format not available', () => {
      // Mock 环境变量控制格式选择
      const converter = new WslToWindowsPathConverter('Ubuntu', { useOldFormat: true });
      const result = converter.convert('/home/user/project');
      assert.strictEqual(result, '\\\\wsl$\\Ubuntu\\home\\user\\project');
    });
  });
});
```

#### WindowsToWslPathConverter

```typescript
describe('WindowsToWslPathConverter', () => {
  describe('基本路径转换', () => {
    it('should convert C drive to /mnt/c', () => {
      const converter = new WindowsToWslPathConverter();
      const result = converter.convert('C:\\Users\\user\\project');
      assert.strictEqual(result, '/mnt/c/Users/user/project');
    });

    it('should convert D drive to /mnt/d', () => {
      const converter = new WindowsToWslPathConverter();
      const result = converter.convert('D:\\data\\project');
      assert.strictEqual(result, '/mnt/d/data/project');
    });

    it('should convert E drive to /mnt/e', () => {
      const converter = new WindowsToWslPathConverter();
      const result = converter.convert('E:\\files\\project');
      assert.strictEqual(result, '/mnt/e/files/project');
    });

    it('should handle backslashes correctly', () => {
      const converter = new WindowsToWslPathConverter();
      const result = converter.convert('C:\\Users\\user\\project');
      assert.ok(!result.includes('\\'));
    });
  });

  describe('边界情况', () => {
    it('should handle path with spaces', () => {
      const converter = new WindowsToWslPathConverter();
      const result = converter.convert('C:\\Users\\user\\My Project');
      assert.strictEqual(result, '/mnt/c/Users/user/My Project');
    });

    it('should handle path with unicode characters', () => {
      const converter = new WindowsToWslPathConverter();
      const result = converter.convert('C:\\Users\\user\\项目');
      assert.ok(result.includes('项目'));
    });

    it('should throw error on UNC path', () => {
      const converter = new WindowsToWslPathConverter();
      assert.throws(() => converter.convert('\\\\server\\share\\file'));
    });

    it('should throw error on empty path', () => {
      const converter = new WindowsToWslPathConverter();
      assert.throws(() => converter.convert(''));
    });

    it('should throw error on relative path', () => {
      const converter = new WindowsToWslPathConverter();
      // 相对路径无法确定驱动器
      assert.throws(() => converter.convert('..\\project'));
    });

    it('should handle path with trailing backslash', () => {
      const converter = new WindowsToWslPathConverter();
      const result = converter.convert('C:\\Users\\user\\');
      assert.strictEqual(result, '/mnt/c/Users/user/');
    });
  });

  describe('小写盘符', () => {
    it('should handle lowercase drive letter', () => {
      const converter = new WindowsToWslPathConverter();
      const result = converter.convert('c:\\Users\\user\\project');
      assert.strictEqual(result, '/mnt/c/Users/user/project');
    });
  });
});
```

#### 覆盖率目标: 95%+

---

### 2.5 数据面层 (DataFacade)

**测试文件**: `src/test/unit/dataFacade.test.ts`

#### NativeDataFacade

```typescript
describe('NativeDataFacade', () => {
  let mockEnvironment: Environment;
  let mockFs: any;

  beforeEach(() => {
    mockEnvironment = {
      type: EnvironmentType.Windows,
      homeDir: 'C:\\Users\\test',
      getConfigPath: () => 'C:\\Users\\test\\.claude.json',
      joinPath: (...segments: string[]) => segments.join('\\'),
      isWindows: () => true,
      isWSL: () => false,
      isMacOS: () => false,
      isLinux: () => false
    };

    // 使用 memfs 隔离文件系统
    mockFs = vol.fromJSON({
      'C:\\Users\\test\\.claude.json': JSON.stringify({
        projects: [
          { path: 'C:\\Users\\test\\project1' },
          { path: 'D:\\data\\project2' }
        ]
      })
    });
  });

  afterEach(() => {
    vol.reset();
  });

  describe('getProjects()', () => {
    it('should return projects array', async () => {
      const facade = new NativeDataFacade(mockEnvironment);
      const projects = await facade.getProjects();
      assert.strictEqual(projects.length, 2);
      assert.strictEqual(projects[0].path, 'C:\\Users\\test\\project1');
    });

    it('should return empty array when no projects', async () => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] })
      });
      const facade = new NativeDataFacade(mockEnvironment);
      const projects = await facade.getProjects();
      assert.strictEqual(projects.length, 0);
    });

    it('should return empty array when projects key missing', async () => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({})
      });
      const facade = new NativeDataFacade(mockEnvironment);
      const projects = await facade.getProjects();
      assert.strictEqual(projects.length, 0);
    });

    it('should throw on malformed JSON', async () => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': 'invalid json{'
      });
      const facade = new NativeDataFacade(mockEnvironment);
      await assert.rejects(async () => await facade.getProjects());
    });

    it('should throw on missing config file', async () => {
      vol.fromJSON({}); // 空文件系统
      const facade = new NativeDataFacade(mockEnvironment);
      await assert.rejects(async () => await facade.getProjects());
    });
  });

  describe('getGlobalConfig()', () => {
    beforeEach(() => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({
          projects: [{ path: 'C:\\project' }],
          globalKey: 'globalValue',
          nested: { key: 'nestedValue' }
        })
      });
    });

    it('should return value for existing key', async () => {
      const facade = new NativeDataFacade(mockEnvironment);
      const value = await facade.getGlobalConfig('globalKey');
      assert.strictEqual(value, 'globalValue');
    });

    it('should return undefined for missing key', async () => {
      const facade = new NativeDataFacade(mockEnvironment);
      const value = await facade.getGlobalConfig('missingKey');
      assert.strictEqual(value, undefined);
    });

    it('should return nested value', async () => {
      const facade = new NativeDataFacade(mockEnvironment);
      const value = await facade.getGlobalConfig('nested.key');
      assert.strictEqual(value, 'nestedValue');
    });
  });

  describe('getEnvironmentInfo()', () => {
    it('should return environment type', async () => {
      const facade = new NativeDataFacade(mockEnvironment);
      const info = facade.getEnvironmentInfo();
      assert.strictEqual(info.type, EnvironmentType.Windows);
    });

    it('should return config path', async () => {
      const facade = new NativeDataFacade(mockEnvironment);
      const info = facade.getEnvironmentInfo();
      assert.strictEqual(info.configPath, 'C:\\Users\\test\\.claude.json');
    });
  });

  describe('跨平台兼容性', () => {
    it('should work on Windows', async () => {
      const windowsEnv = { ...mockEnvironment, type: EnvironmentType.Windows };
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] })
      });
      const facade = new NativeDataFacade(windowsEnv);
      await facade.getProjects(); // 不应抛出错误
    });

    it('should work on macOS', async () => {
      const macEnv = {
        type: EnvironmentType.MacOS,
        homeDir: '/Users/test',
        getConfigPath: () => '/Users/test/.claude.json',
        joinPath: (...s: string[]) => s.join('/'),
        isWindows: () => false,
        isWSL: () => false,
        isMacOS: () => true,
        isLinux: () => false
      };
      vol.fromJSON({
        '/Users/test/.claude.json': JSON.stringify({ projects: [] })
      });
      const facade = new NativeDataFacade(macEnv);
      await facade.getProjects();
    });

    it('should work on Linux', async () => {
      const linuxEnv = {
        type: EnvironmentType.Linux,
        homeDir: '/home/test',
        getConfigPath: () => '/home/test/.claude.json',
        joinPath: (...s: string[]) => s.join('/'),
        isWindows: () => false,
        isWSL: () => false,
        isMacOS: () => false,
        isLinux: () => true
      };
      vol.fromJSON({
        '/home/test/.claude.json': JSON.stringify({ projects: [] })
      });
      const facade = new NativeDataFacade(linuxEnv);
      await facade.getProjects();
    });
  });
});
```

#### WindowsToWslDataFacade

```typescript
describe('WindowsToWslDataFacade', () => {
  let mockEnvironment: Environment;
  let mockPathConverter: WslToWindowsPathConverter;

  beforeEach(() => {
    mockEnvironment = {
      type: EnvironmentType.Windows,
      homeDir: 'C:\\Users\\test',
      getConfigPath: () => 'C:\\Users\\test\\.claude.json',
      joinPath: (...segments: string[]) => segments.join('\\'),
      isWindows: () => true,
      isWSL: () => false,
      isMacOS: () => false,
      isLinux: () => false
    };

    mockPathConverter = {
      convert: sinon.stub().returns('\\\\wsl.localhost\\Ubuntu\\converted\\path')
    } as any;
  });

  describe('getProjects()', () => {
    it('should convert WSL paths to Windows UNC paths', async () => {
      const wslConfig = {
        projects: [
          { path: '/home/user/project1' },
          { path: '/var/www/project2' }
        ]
      };

      // Mock WSL 文件系统访问
      vol.fromJSON({
        '\\\\wsl.localhost\\Ubuntu\\home\\user\\.claude.json': JSON.stringify(wslConfig)
      });

      const facade = new WindowsToWslDataFacade('Ubuntu', mockEnvironment, mockPathConverter);
      const projects = await facade.getProjects();

      assert.strictEqual(projects.length, 2);
      assert.ok(mockPathConverter.convert.calledTwice);
    });

    it('should use correct instance name in paths', async () => {
      vol.fromJSON({
        '\\\\wsl.localhost\\Ubuntu-22.04\\home\\user\\.claude.json': JSON.stringify({
          projects: [{ path: '/home/test/project' }]
        })
      });

      const facade = new WindowsToWslDataFacade('Ubuntu-22.04', mockEnvironment, mockPathConverter);
      const info = facade.getEnvironmentInfo();
      assert.strictEqual(info.instanceName, 'Ubuntu-22.04');
    });
  });

  describe('路径转换', () => {
    it('should use new format by default', async () => {
      const converter = new WslToWindowsPathConverter('Ubuntu');
      const result = converter.convert('/home/test');
      assert.ok(result.includes('\\\\wsl.localhost\\'));
    });
  });

  describe('错误处理', () => {
    it('should handle WSL not accessible', async () => {
      // Mock WSL 访问失败
      vol.fromJSON({}); // 空文件系统

      const facade = new WindowsToWslDataFacade('Ubuntu', mockEnvironment, mockPathConverter);
      await assert.rejects(async () => await facade.getProjects());
    });
  });
});
```

#### WslToWindowsDataFacade

```typescript
describe('WslToWindowsDataFacade', () => {
  let mockEnvironment: Environment;
  let mockPathConverter: WindowsToWslPathConverter;

  beforeEach(() => {
    mockEnvironment = {
      type: EnvironmentType.WSL,
      homeDir: '/home/test',
      getConfigPath: () => '/home/test/.claude.json',
      joinPath: (...segments: string[]) => segments.join('/'),
      isWindows: () => false,
      isWSL: () => true,
      isMacOS: () => false,
      isLinux: () => false
    };

    mockPathConverter = {
      convert: sinon.stub().returns('/mnt/c/converted/path')
    } as any;
  });

  describe('getProjects()', () => {
    it('should convert Windows paths to WSL paths', async () => {
      const windowsConfig = {
        projects: [
          { path: 'C:\\Users\\user\\project1' },
          { path: 'D:\\data\\project2' }
        ]
      };

      vol.fromJSON({
        '/mnt/c/Users/user/.claude.json': JSON.stringify(windowsConfig)
      });

      const facade = new WslToWindowsDataFacade(mockEnvironment, mockPathConverter);
      const projects = await facade.getProjects();

      assert.strictEqual(projects.length, 2);
      assert.ok(mockPathConverter.convert.calledTwice);
    });

    it('should handle different drives', async () => {
      const converter = new WindowsToWslPathConverter();
      assert.strictEqual(converter.convert('C:\\path'), '/mnt/c/path');
      assert.strictEqual(converter.convert('D:\\path'), '/mnt/d/path');
      assert.strictEqual(converter.convert('E:\\path'), '/mnt/e/path');
    });
  });

  describe('错误处理', () => {
    it('should handle Windows not accessible', async () => {
      vol.fromJSON({}); // /mnt/c 不存在

      const facade = new WslToWindowsDataFacade(mockEnvironment, mockPathConverter);
      await assert.rejects(async () => await facade.getProjects());
    });
  });
});
```

#### 覆盖率目标: 90%+

---

### 2.6 配置搜索层 (ConfigSearch)

**测试文件**: `src/test/unit/configSearch.test.ts`

```typescript
describe('ConfigSearch', () => {
  let mockEnvironment: Environment;

  beforeEach(() => {
    mockEnvironment = {
      type: EnvironmentType.Windows,
      homeDir: 'C:\\Users\\test',
      getConfigPath: () => 'C:\\Users\\test\\.claude.json',
      joinPath: (...segments: string[]) => segments.join('\\'),
      isWindows: () => true,
      isWSL: () => false,
      isMacOS: () => false,
      isLinux: () => false
    };
  });

  describe('discoverAll() - Windows 环境', () => {
    beforeEach(() => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] })
      });
    });

    it('should discover Native environment', async () => {
      const search = new ConfigSearch(mockEnvironment);
      const facades = await search.discoverAll();

      const native = facades.find(f => f instanceof NativeDataFacade);
      assert.ok(native);
    });

    it('should discover WSL instances', async () => {
      // Mock WSL 实例存在
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] }),
        '\\\\wsl.localhost\\Ubuntu\\home\\user\\.claude.json': JSON.stringify({ projects: [] }),
        '\\\\wsl.localhost\\Debian\\home\\user\\.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      const facades = await search.discoverAll();

      const wslFacades = facades.filter(f => f instanceof WindowsToWslDataFacade);
      assert.strictEqual(wslFacades.length, 2);
    });

    it('should skip WSL without .claude.json', async () => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] }),
        '\\\\wsl.localhost\\Ubuntu\\home\\user\\other.txt': 'content'
      });

      const search = new ConfigSearch(mockEnvironment);
      const facades = await search.discoverAll();

      // 应该只有 NativeDataFacade
      assert.strictEqual(facades.length, 1);
      assert.ok(facades[0] instanceof NativeDataFacade);
    });

    it('should handle no WSL installed', async () => {
      // Mock 不存在 WSL
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      const facades = await search.discoverAll();

      assert.strictEqual(facades.length, 1);
    });
  });

  describe('discoverAll() - WSL 环境', () => {
    beforeEach(() => {
      mockEnvironment = {
        type: EnvironmentType.WSL,
        homeDir: '/home/test',
        getConfigPath: () => '/home/test/.claude.json',
        joinPath: (...s: string[]) => s.join('/'),
        isWindows: () => false,
        isWSL: () => true,
        isMacOS: () => false,
        isLinux: () => false
      };
    });

    it('should discover Native environment', async () => {
      vol.fromJSON({
        '/home/test/.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      const facades = await search.discoverAll();

      const native = facades.find(f => f instanceof NativeDataFacade);
      assert.ok(native);
    });

    it('should discover Windows environment', async () => {
      vol.fromJSON({
        '/home/test/.claude.json': JSON.stringify({ projects: [] }),
        '/mnt/c/Users/test/.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      const facades = await search.discoverAll();

      const windows = facades.find(f => f instanceof WslToWindowsDataFacade);
      assert.ok(windows);
    });

    it('should skip Windows without .claude.json', async () => {
      vol.fromJSON({
        '/home/test/.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      const facades = await search.discoverAll();

      assert.strictEqual(facades.length, 1);
      assert.ok(facades[0] instanceof NativeDataFacade);
    });
  });

  describe('discoverAll() - macOS 环境', () => {
    beforeEach(() => {
      mockEnvironment = {
        type: EnvironmentType.MacOS,
        homeDir: '/Users/test',
        getConfigPath: () => '/Users/test/.claude.json',
        joinPath: (...s: string[]) => s.join('/'),
        isWindows: () => false,
        isWSL: () => false,
        isMacOS: () => true,
        isLinux: () => false
      };
    });

    it('should only discover Native environment', async () => {
      vol.fromJSON({
        '/Users/test/.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      const facades = await search.discoverAll();

      assert.strictEqual(facades.length, 1);
      assert.ok(facades[0] instanceof NativeDataFacade);
    });
  });

  describe('refresh()', () => {
    it('should re-discover all environments', async () => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      await search.discoverAll();

      // 添加新的 WSL 配置
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] }),
        '\\\\wsl.localhost\\Ubuntu\\home\\user\\.claude.json': JSON.stringify({ projects: [] })
      });

      const facades = await search.refresh();
      assert.strictEqual(facades.length, 2);
    });

    it('should remove deleted environments', async () => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] }),
        '\\\\wsl.localhost\\Ubuntu\\home\\user\\.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      await search.discoverAll();

      // 移除 WSL 配置
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] })
      });

      const facades = await search.refresh();
      assert.strictEqual(facades.length, 1);
    });

    it('should trigger onDataFacadesChanged event', async () => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      let eventFired = false;
      search.onDataFacadesChanged(() => { eventFired = true; });

      await search.refresh();
      assert.ok(eventFired);
    });
  });

  describe('缓存', () => {
    it('should cache discovery results', async () => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      const facades1 = await search.discoverAll();
      const facades2 = await search.discoverAll();

      // 验证返回相同的实例（缓存）
      assert.strictEqual(facades1.length, facades2.length);
    });

    it('should invalidate cache on refresh', async () => {
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] })
      });

      const search = new ConfigSearch(mockEnvironment);
      await search.discoverAll();

      // 添加新环境
      vol.fromJSON({
        'C:\\Users\\test\\.claude.json': JSON.stringify({ projects: [] }),
        '\\\\wsl.localhost\\Ubuntu\\home\\user\\.claude.json': JSON.stringify({ projects: [] })
      });

      const facades = await search.refresh();
      assert.strictEqual(facades.length, 2);
    });
  });
});
```

#### 覆盖率目标: 90%+

---

### 2.7 渲染层 (Views)

**测试文件**: `src/test/unit/globalProvider.test.ts`

```typescript
describe('GlobalProvider', () => {
  let mockDataFacades: ClaudeDataFacade[];
  let mockConfigSearch: ConfigSearch;

  beforeEach(() => {
    mockDataFacades = [
      {
        getEnvironmentInfo: () => ({
          type: EnvironmentType.Windows,
          configPath: 'C:\\Users\\test\\.claude.json'
        }),
        getProjects: async () => [],
        getGlobalConfig: async () => undefined
      }
    ];

    mockConfigSearch = {
      discoverAll: async () => mockDataFacades,
      onDataFacadesChanged: () => {}
    } as any;
  });

  describe('数据面集成', () => {
    it('should display all environments', () => {
      const provider = new GlobalProvider(mockConfigSearch);
      const treeItem = provider.getTreeItem('root');

      assert.ok(treeItem);
    });

    it('should update on data facades changed', () => {
      const provider = new GlobalProvider(mockConfigSearch);
      let refreshed = false;
      provider.refresh = () => { refreshed = true; };

      // 触发事件
      mockConfigSearch.onDataFacadesChanged(() => provider.refresh());

      assert.ok(refreshed);
    });
  });

  describe('getChildren()', () => {
    it('should return root level children', async () => {
      const provider = new GlobalProvider(mockConfigSearch);
      const children = await provider.getChildren();

      assert.ok(Array.isArray(children));
    });
  });
});
```

#### 覆盖率目标: 80%+

---

## 3. 单元测试执行

### 3.1 运行命令

```bash
# 运行所有单元测试
npm run test

# 运行单个测试文件
npm run test -- environment.test.ts

# 监听模式
npm run test:watch

# 覆盖率报告
npm run test:coverage
```

### 3.2 覆盖率目标

| 模块 | 目标覆盖率 |
|:---|:---:|
| 环境层 (Environment) | 100% |
| 路径转换层 (PathConverter) | 95% |
| NativeDataFacade | 90% |
| WindowsToWslDataFacade | 90% |
| WslToWindowsDataFacade | 90% |
| 配置搜索层 (ConfigSearch) | 90% |
| 渲染层 (Views) | 80% |
| **整体** | **90%** |

### 3.3 通过要求

- **所有单元测试必须 100% 通过**
- **整体覆盖率必须 ≥ 90%**
- **关键模块（环境层、路径转换）覆盖率 ≥ 95%**

---

## 4. 集成测试（单独任务）

集成测试将作为单独的开发任务，在单元测试全部通过后进行。

### 4.1 集成测试范围

- 真实环境下的模块协作
- Windows + WSL 跨环境访问
- WSL 实例启动/停止
- 配置文件变化监听
- VS Code 扩展生命周期

### 4.2 测试环境

| 环境 | 用途 |
|:---|:---|
| Windows 11 + WSL2 | 主要测试环境 |
| Ubuntu 22.04 (WSL) | WSL 测试 |
| 真机 | 最终验证 |

---

## 5. 检查清单

### 5.1 提交前检查

- [ ] 所有单元测试通过
- [ ] 代码覆盖率 ≥ 90%
- [ ] Lint 检查通过
- [ ] TypeScript 编译无错误

### 5.2 合并前检查

- [ ] 所有单元测试通过
- [ ] 代码覆盖率达标
- [ ] Code Review 完成

### 5.3 发布前检查

- [ ] 单元测试全部通过
- [ ] 集成测试全部通过
- [ ] 真机测试通过
- [ ] 性能测试通过
